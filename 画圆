import time
# Import piper_sdk module
from piper_sdk import *

if __name__ == "__main__":
    # Instantiate interface, the default parameters of the parameters are as follows
    #   can_name(str): can port name
    #   judge_flag(bool): Whether to enable the can module when creating this instance.
    #                     If you use an unofficial module, please set it to False
    #   can_auto_init(bool): Whether to automatically initialize to open the can bus when creating this instance.
    #                        If set to False, please set the can_init parameter to True in the ConnectPort parameter
    #   dh_is_offset([0,1] -> default 0x01): Whether the dh parameter used is the new version of dh or the old version of dh.
    #                                       The old version is before S-V1.6-3, and the new version is after S-V1.6-3 firmware
    #           0 -> old
    #           1 -> new
    #   start_sdk_joint_limit(bool -> False): Whether to enable SDK joint angle limit, which will limit both feedback and control messages
    #   start_sdk_gripper_limit(bool -> False): Whether to enable SDK gripper position limit, which will limit both feedback and control messages
    #   logger_level(LogLevel -> default LogLevel.WARNING): Set the log level
    #         The following parameters are optional:
    #               LogLevel.DEBUG
    #               LogLevel.INFO
    #               LogLevel.WARNING
    #               LogLevel.ERROR
    #               LogLevel.CRITICAL
    #               LogLevel.SILENT
    #   log_to_file(bool -> default False): Whether to enable the log writing function, True to enable, default to disable
    #   log_file_path(str -> default False): Set the path to write the log file, the default is the log folder under the sdk path
    piper = C_PiperInterface(can_name="can0",
                                judge_flag=False,
                                can_auto_init=True,
                                dh_is_offset=1,
                                start_sdk_joint_limit=False,
                                start_sdk_gripper_limit=False,
                                logger_level=LogLevel.WARNING,
                                log_to_file=False,
                                log_file_path=None)
    # Enable can send and receive threads
    piper.ConnectPort()
    # Loop and print messages. Note that the first frame of all messages is the default value. For example, the message content of the first frame of the joint angle message defaults to 0
    while True:
        import threading
        import queue
        import numpy as np
        import matplotlib.pyplot as plt
        import time  # 补充缺失的time导入


        # 假设piper已正确初始化（根据实际情况补充）
        # piper = ...  # 机械臂对象初始化代码

        class ContinuousMotion:
            def __init__(self):
                self.arm = piper  # 机械臂对象
                self.running = False  # 运动标志位
                self.lock = threading.Lock()  # 仅保护机械臂发送操作
                self.point_buffer = []  # 保留缓冲区但控制长度，避免堆积

                # 关键1：队列设为容量1，强制“生成一个、发送一个”，无缓冲堆积
                self.plot_queue = queue.Queue(maxsize=1)

                # 绘图初始化（关键优化：启用Blitting加速，预设坐标轴范围）
                self.x_history = []
                self.y_history = []
                plt.ion()
                self.fig, self.ax = plt.subplots(figsize=(8, 6), dpi=80)  # 降低dpi减少绘图负载
                self.line, = self.ax.plot([], [], 'b-', linewidth=2, animated=True)  # 开启动画模式（Blitting必需）
                self.ax.set_xlabel('X坐标 (mm)')
                self.ax.set_ylabel('Y坐标 (mm)')
                self.ax.set_title('机械臂实时轨迹（圆形轨迹）')
                self.ax.grid(True, linestyle='--', alpha=0.5)  # 简化网格，降低绘制耗时

                # 调整坐标轴范围以适应圆形轨迹（根据圆心和半径调整）
                self.ax.set_xlim(-160, -40)  # 扩大X范围以容纳圆形
                self.ax.set_ylim(260, 340)  # 扩大Y范围以容纳圆形

                # Blitting初始化：只重绘变化的线条，绘图耗时压缩到1-2ms
                self.fig.canvas.draw()
                self.background = self.fig.canvas.copy_from_bbox(self.ax.bbox)
                self.fig.canvas.blit(self.ax.bbox)

            def init_arm(self):
                """初始化机械臂（保持原有逻辑）"""
                if not self.arm.EnablePiper():
                    raise RuntimeError("机械臂使能失败")
                self.arm.ModeCtrl(ctrl_mode=0x01, move_mode=0x01, move_spd_rate_ctrl=20)
                time.sleep(2)
                self.arm.JointCtrl(0, 0, 0, 0, 0, 0)
                time.sleep(3)
                self.arm.ModeCtrl(ctrl_mode=0x01, move_mode=0x00, move_spd_rate_ctrl=20)
                time.sleep(2)
                self.arm.EndPoseCtrl(-53044, 298102, 31758, 176745, -915, -86313)
                time.sleep(3)
                self.arm.ModeCtrl(ctrl_mode=0x01, move_mode=0x02, move_spd_rate_ctrl=15)
                time.sleep(2)
                print("机械臂初始化完成，进入连续运动模式")

            def generate_continuous_points(self, total_points=300):
                """生成圆形轨迹点（保持原有节奏控制，仅修改轨迹计算）"""
                # 圆形参数设置
                center_x = -100000  # 圆心X坐标（单位：0.01mm，对应-100mm）
                center_y = 298102  # 圆心Y坐标（沿用初始Y值）
                radius = 30000  # 半径（单位：0.01mm，对应30mm）

                # 生成圆形轨迹点（角度从0到2π，均匀分布）
                for i in range(total_points):
                    angle = 2 * np.pi * i / total_points  # 角度（0到2π循环）

                    # 计算圆形轨迹点（x=圆心x+半径*cosθ，y=圆心y+半径*sinθ）
                    x = center_x + int(radius * np.cos(angle))
                    y = center_y + int(radius * np.sin(angle))
                    z = 31758  # 保持Z坐标不变
                    rx, ry, rz = 176745, -915, -86313  # 保持姿态不变

                    # 控制缓冲区长度≤1，避免生成过快导致堆积
                    with self.lock:
                        if len(self.point_buffer) < 1:
                            self.point_buffer.append((x, y, z, rx, ry, rz))

                    # 保持生成节奏与发送/绘图对齐
                    time.sleep(0.02)

            def send_continuous_points(self):
                """子线程：发送点位并即时入队，无额外延迟"""
                print("开始连续发送点位...")
                while self.running or len(self.point_buffer) > 0:
                    with self.lock:
                        if self.point_buffer:
                            current_pose = self.point_buffer.pop(0)
                            self.arm.EndPoseCtrl(*current_pose)
                            x_mm = current_pose[0] / 1000
                            y_mm = current_pose[1] / 1000
                            print(f"发送点位：X={x_mm:.2f}mm, Y={y_mm:.2f}mm")

                            # 队列满时阻塞，确保“发送一个才入队下一个”
                            self.plot_queue.put((x_mm, y_mm), block=True)

                    # 发送延迟保持0.02s，与生成/绘图节奏匹配
                    time.sleep(0.02)

                # 发送结束标志
                self.plot_queue.put(None)

            def update_plot(self):
                """Blitting极速绘图，消除延迟"""
                while True:
                    item = self.plot_queue.get(timeout=1)
                    if item is None:
                        break
                    x, y = item
                    self.x_history.append(x)
                    self.y_history.append(y)

                    # 更新轨迹数据
                    self.line.set_xdata(self.x_history)
                    self.line.set_ydata(self.y_history)

                    # Blitting快速重绘（仅更新线条，不重绘整个画布）
                    self.fig.canvas.restore_region(self.background)  # 恢复背景
                    self.ax.draw_artist(self.line)  # 只绘制变化的线条
                    self.fig.canvas.blit(self.ax.bbox)  # 刷新变化区域
                    self.fig.canvas.flush_events()  # 处理事件，避免卡顿

                # 所有点处理完成后保持图像
                plt.ioff()
                plt.show()

            def start(self, total_points=100):
                """启动流程（保持原有线程结构，优化节奏对齐）"""
                self.running = True

                # 启动点位生成线程
                gen_thread = threading.Thread(target=self.generate_continuous_points, args=(total_points,))
                gen_thread.start()

                # 启动点位发送线程
                send_thread = threading.Thread(target=self.send_continuous_points)
                send_thread.start()

                # 主线程负责绘图（确保绘图在主线程，无线程冲突）
                self.update_plot()

                # 等待子线程结束
                gen_thread.join()
                send_thread.join()
                print("所有点位发送完成")

            def __del__(self):
                """析构函数：失能机械臂"""
                if hasattr(self, 'arm'):
                    # self.arm.DisablePiper()  # 补充机械臂失能方法
                    print("机械臂已失能")


        if __name__ == "__main__":
            try:
                motion = ContinuousMotion()
                motion.init_arm()
                motion.start(total_points=200)  # 启动连续运动（200个点足够绘制完整圆形）
            except Exception as e:
                print(f"执行错误：{e}")
