import time
# Import piper_sdk module
from piper_sdk import *

if __name__ == "__main__":
    # Instantiate interface, the default parameters of the parameters are as follows
    #   can_name(str): can port name
    #   judge_flag(bool): Whether to enable the can module when creating this instance.
    #                     If you use an unofficial module, please set it to False
    #   can_auto_init(bool): Whether to automatically initialize to open the can bus when creating this instance.
    #                        If set to False, please set the can_init parameter to True in the ConnectPort parameter
    #   dh_is_offset([0,1] -> default 0x01): Whether the dh parameter used is the new version of dh or the old version of dh.
    #                                       The old version is before S-V1.6-3, and the new version is after S-V1.6-3 firmware
    #           0 -> old
    #           1 -> new
    #   start_sdk_joint_limit(bool -> False): Whether to enable SDK joint angle limit, which will limit both feedback and control messages
    #   start_sdk_gripper_limit(bool -> False): Whether to enable SDK gripper position limit, which will limit both feedback and control messages
    #   logger_level(LogLevel -> default LogLevel.WARNING): Set the log level
    #         The following parameters are optional:
    #               LogLevel.DEBUG
    #               LogLevel.INFO
    #               LogLevel.WARNING
    #               LogLevel.ERROR
    #               LogLevel.CRITICAL
    #               LogLevel.SILENT
    #   log_to_file(bool -> default False): Whether to enable the log writing function, True to enable, default to disable
    #   log_file_path(str -> default False): Set the path to write the log file, the default is the log folder under the sdk path
    piper = C_PiperInterface(can_name="can0",
                             judge_flag=False,
                             can_auto_init=True,
                             dh_is_offset=1,
                             start_sdk_joint_limit=False,
                             start_sdk_gripper_limit=False,
                             logger_level=LogLevel.WARNING,
                             log_to_file=False,
                             log_file_path=None)
    # Enable can send and receive threads
    piper.ConnectPort()
    # Loop and print messages. Note that the first frame of all messages is the default value. For example, the message content of the first frame of the joint angle message defaults to 0
    while True:
        import threading
        import queue
        import numpy as np
        import matplotlib.pyplot as plt


        # 假设piper已正确初始化（根据实际情况补充）
        # piper = ...  # 机械臂对象初始化代码

        class ContinuousMotion:
            def __init__(self):
                self.arm = piper  # 机械臂对象
                self.running = False  # 运动标志位
                self.point_buffer = []  # 点位缓冲区
                self.lock = threading.Lock()  # 线程锁（保护缓冲区）

                # 新增：线程安全的消息队列（子线程传坐标给主线程绘图）
                self.plot_queue = queue.Queue()

                # 绘图相关初始化（主线程）
                self.x_history = []
                self.y_history = []
                plt.ion()  # 开启交互模式
                self.fig, self.ax = plt.subplots(figsize=(8, 6))
                self.line, = self.ax.plot([], [], 'b-', linewidth=2)
                self.ax.set_xlabel('X坐标 (mm)')
                self.ax.set_ylabel('Y坐标 (mm)')
                self.ax.set_title('机械臂运动轨迹实时显示')
                self.ax.grid(True)

            def init_arm(self):
                """初始化机械臂，设置为连续运动模式"""
                if not self.arm.EnablePiper():
                    raise RuntimeError("机械臂使能失败")
                # 设置为MOVE L模式（直线连续运动），速度15%
                self.arm.ModeCtrl(ctrl_mode=0x01, move_mode=0x01, move_spd_rate_ctrl=20)
                time.sleep(2)
                self.arm.JointCtrl(0, 0, 0, 0, 0, 0)
                time.sleep(3)

                self.arm.ModeCtrl(ctrl_mode=0x01, move_mode=0x00, move_spd_rate_ctrl=20)
                time.sleep(2)
                self.arm.EndPoseCtrl(-53044, 298102, 31758, 176745, -915, -86313)
                time.sleep(3)

                self.arm.ModeCtrl(ctrl_mode=0x01, move_mode=0x02, move_spd_rate_ctrl=15)
                time.sleep(2)
                print("机械臂初始化完成，进入连续运动模式")

            def generate_continuous_points(self, total_points=300):
                """生成源源不断的点位（示例：正弦曲线轨迹）"""
                start_x, start_y, start_z, rx, ry, rz = (-53044, 298102, 31758, 176745, -915, -86313)
                for i in range(total_points):
                    x = start_x - i * 1000  # X每步增加1mm（1000单位）
                    y = start_y + int(30000 * np.sin(i * 0.1))  # Y波动幅度±30mm
                    z = start_z
                    with self.lock:
                        self.point_buffer.append((x, y, z, rx, ry, rz))
                    time.sleep(0.05)  # 模拟实时生成延迟

            def send_continuous_points(self):
                """子线程：发送点位并将坐标放入绘图队列"""
                print("开始连续发送点位...")
                while self.running or len(self.point_buffer) > 0:
                    with self.lock:
                        if self.point_buffer:
                            current_pose = self.point_buffer.pop(0)
                            self.arm.EndPoseCtrl(*current_pose)
                            x_mm = current_pose[0] / 1000
                            y_mm = current_pose[1] / 1000
                            print(f"发送点位：X={x_mm}mm, Y={y_mm}mm")

                            # 将坐标放入队列，由主线程绘图
                            self.plot_queue.put((x_mm, y_mm))

                    time.sleep(0.02)  # 控制发送频率

                # 发送结束标志
                self.plot_queue.put(None)

            def update_plot(self):
                """主线程：从队列取数据并更新绘图"""
                while True:
                    # 从队列取数据（超时1秒，避免阻塞）
                    item = self.plot_queue.get(timeout=1)
                    if item is None:  # 收到结束标志
                        break
                    x, y = item
                    self.x_history.append(x)
                    self.y_history.append(y)

                    # 更新轨迹
                    self.line.set_xdata(self.x_history)
                    self.line.set_ydata(self.y_history)
                    self.ax.relim()  # 自动调整坐标轴
                    self.ax.autoscale_view()
                    self.fig.canvas.draw()
                    self.fig.canvas.flush_events()

                # 所有点处理完成后保持图像
                plt.ioff()
                plt.show()

            def start(self, total_points=100):
                """启动流程：生成线程 + 发送线程 + 主线程绘图"""
                self.running = True

                # 启动点位生成线程
                gen_thread = threading.Thread(target=self.generate_continuous_points, args=(total_points,))
                gen_thread.start()

                # 启动点位发送线程
                send_thread = threading.Thread(target=self.send_continuous_points)
                send_thread.start()

                # 主线程负责绘图（关键：绘图在主线程执行）
                self.update_plot()

                # 等待子线程结束
                gen_thread.join()
                send_thread.join()
                print("所有点位发送完成")

            def __del__(self):
                """析构函数：失能机械臂"""
                if hasattr(self, 'arm'):
                    # 假设有关闭机械臂的方法，根据实际API修改
                    # self.arm.DisablePiper()
                    print("机械臂已失能")


        if __name__ == "__main__":
            try:
                motion = ContinuousMotion()
                motion.init_arm()
                motion.start(total_points=100)  # 启动连续运动
            except Exception as e:
                print(f"执行错误：{e}")
