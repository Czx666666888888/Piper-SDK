import time
# Import piper_sdk module
from piper_sdk import *

if __name__ == "__main__":
    # Instantiate interface, the default parameters of the parameters are as follows
    #   can_name(str): can port name
    #   judge_flag(bool): Whether to enable the can module when creating this instance.
    #                     If you use an unofficial module, please set it to False
    #   can_auto_init(bool): Whether to automatically initialize to open the can bus when creating this instance.
    #                        If set to False, please set the can_init parameter to True in the ConnectPort parameter
    #   dh_is_offset([0,1] -> default 0x01): Whether the dh parameter used is the new version of dh or the old version of dh.
    #                                       The old version is before S-V1.6-3, and the new version is after S-V1.6-3 firmware
    #           0 -> old
    #           1 -> new
    #   start_sdk_joint_limit(bool -> False): Whether to enable SDK joint angle limit, which will limit both feedback and control messages
    #   start_sdk_gripper_limit(bool -> False): Whether to enable SDK gripper position limit, which will limit both feedback and control messages
    #   logger_level(LogLevel -> default LogLevel.WARNING): Set the log level
    #         The following parameters are optional:
    #               LogLevel.DEBUG
    #               LogLevel.INFO
    #               LogLevel.WARNING
    #               LogLevel.ERROR
    #               LogLevel.CRITICAL
    #               LogLevel.SILENT
    #   log_to_file(bool -> default False): Whether to enable the log writing function, True to enable, default to disable
    #   log_file_path(str -> default False): Set the path to write the log file, the default is the log folder under the sdk path
    piper = C_PiperInterface(can_name="can0",
                                judge_flag=False,
                                can_auto_init=True,
                                dh_is_offset=1,
                                start_sdk_joint_limit=False,
                                start_sdk_gripper_limit=False,
                                logger_level=LogLevel.WARNING,
                                log_to_file=False,
                                log_file_path=None)
    # Enable can send and receive threads
    piper.ConnectPort()
    # Loop and print messages. Note that the first frame of all messages is the default value. For example, the message content of the first frame of the joint angle message defaults to 0
    while True:
        import threading
        import queue
        import numpy as np
        import matplotlib.pyplot as plt


        # 假设piper已正确初始化（根据实际情况补充）
        # piper = ...  # 机械臂对象初始化代码

        class ContinuousMotion:
            def __init__(self):
                self.arm = piper  # 机械臂对象
                self.running = False  # 运动标志位
                self.lock = threading.Lock()  # 仅保护机械臂发送操作
                self.point_buffer = []  # 保留缓冲区但控制长度，避免堆积

                # 关键1：队列设为容量1，强制“生成一个、发送一个”，无缓冲堆积
                self.plot_queue = queue.Queue(maxsize=1)

                # 绘图初始化（关键优化：启用Blitting加速，预设坐标轴范围）
                self.x_history = []
                self.y_history = []
                plt.ion()
                self.fig, self.ax = plt.subplots(figsize=(8, 6), dpi=80)  # 降低dpi减少绘图负载
                self.line, = self.ax.plot([], [], 'b-', linewidth=2, animated=True)  # 开启动画模式（Blitting必需）
                self.ax.set_xlabel('X坐标 (mm)')
                self.ax.set_ylabel('Y坐标 (mm)')
                self.ax.set_title('机械臂实时轨迹（椭圆轨迹）')  # 标题改为椭圆
                self.ax.grid(True, linestyle='--', alpha=0.5)  # 简化网格，降低绘制耗时

                # 调整坐标轴范围以适应椭圆轨迹（根据椭圆长短轴调整）
                self.ax.set_xlim(-170, -30)  # X方向范围适配长轴
                self.ax.set_ylim(260, 340)  # Y方向范围适配短轴

                # Blitting初始化：只重绘变化的线条，绘图耗时压缩到1-2ms
                self.fig.canvas.draw()
                self.background = self.fig.canvas.copy_from_bbox(self.ax.bbox)
                self.fig.canvas.blit(self.ax.bbox)

            def init_arm(self):
                """初始化机械臂（保持原有逻辑）"""
                if not self.arm.EnablePiper():
                    raise RuntimeError("机械臂使能失败")
                self.arm.ModeCtrl(ctrl_mode=0x01, move_mode=0x01, move_spd_rate_ctrl=20)
                time.sleep(2)
                self.arm.JointCtrl(0, 0, 0, 0, 0, 0)
                time.sleep(3)
                self.arm.ModeCtrl(ctrl_mode=0x01, move_mode=0x00, move_spd_rate_ctrl=20)
                time.sleep(2)
                self.arm.EndPoseCtrl(-53044, 298102, 31758, 176745, -915, -86313)
                time.sleep(3)
                self.arm.ModeCtrl(ctrl_mode=0x01, move_mode=0x02, move_spd_rate_ctrl=15)
                time.sleep(2)
                print("机械臂初始化完成，进入连续运动模式")

            def generate_continuous_points(self, total_points=300):
                """生成椭圆轨迹点（核心修改：用椭圆参数方程替换圆形）"""
                # 椭圆参数设置（单位：0.01mm，与机械臂坐标单位匹配）
                center_x = -100000  # 椭圆中心X坐标（对应-100mm，沿用原圆心）
                center_y = 298102  # 椭圆中心Y坐标（沿用初始Y值）
                semi_major = 50000  # X方向长半轴（对应50mm，长轴方向）
                semi_minor = 20000  # Y方向短半轴（对应20mm，短轴方向）

                # 生成椭圆轨迹点（椭圆参数方程：x=中心x+长半轴*cosθ，y=中心y+短半轴*sinθ）
                for i in range(total_points):
                    angle = 2 * np.pi * i / total_points  # 角度从0到2π循环，均匀覆盖椭圆

                    # 计算椭圆上的点坐标
                    x = center_x + int(semi_major * np.cos(angle))
                    y = center_y + int(semi_minor * np.sin(angle))
                    z = 31758  # 保持Z坐标不变，在同一平面运动
                    rx, ry, rz = 176745, -915, -86313  # 保持姿态不变

                    # 控制缓冲区长度≤1，避免生成过快导致堆积
                    with self.lock:
                        if len(self.point_buffer) < 1:
                            self.point_buffer.append((x, y, z, rx, ry, rz))

                    # 保持生成节奏与发送/绘图对齐
                    time.sleep(0.02)

            def send_continuous_points(self):
                """子线程：发送点位并即时入队，无额外延迟"""
                print("开始连续发送点位...")
                while self.running or len(self.point_buffer) > 0:
                    with self.lock:
                        if self.point_buffer:
                            current_pose = self.point_buffer.pop(0)
                            self.arm.EndPoseCtrl(*current_pose)
                            x_mm = current_pose[0] / 1000
                            y_mm = current_pose[1] / 1000
                            print(f"发送点位：X={x_mm:.2f}mm, Y={y_mm:.2f}mm")

                            # 队列满时阻塞，确保“发送一个才入队下一个”
                            self.plot_queue.put((x_mm, y_mm), block=True)

                    # 发送延迟保持0.02s，与生成/绘图节奏匹配
                    time.sleep(0.02)

                # 发送结束标志
                self.plot_queue.put(None)

            def update_plot(self):
                """Blitting极速绘图，消除延迟"""
                while True:
                    item = self.plot_queue.get(timeout=1)
                    if item is None:
                        break
                    x, y = item
                    self.x_history.append(x)
                    self.y_history.append(y)

                    # 更新轨迹数据
                    self.line.set_xdata(self.x_history)
                    self.line.set_ydata(self.y_history)

                    # Blitting快速重绘（仅更新线条，不重绘整个画布）
                    self.fig.canvas.restore_region(self.background)  # 恢复背景
                    self.ax.draw_artist(self.line)  # 只绘制变化的线条
                    self.fig.canvas.blit(self.ax.bbox)  # 刷新变化区域
                    self.fig.canvas.flush_events()  # 处理事件，避免卡顿

                # 所有点处理完成后保持图像
                plt.ioff()
                plt.show()

            def start(self, total_points=100):
                """启动流程（保持原有线程结构，优化节奏对齐）"""
                self.running = True

                # 启动点位生成线程
                gen_thread = threading.Thread(target=self.generate_continuous_points, args=(total_points,))
                gen_thread.start()

                # 启动点位发送线程
                send_thread = threading.Thread(target=self.send_continuous_points)
                send_thread.start()

                # 主线程负责绘图（确保绘图在主线程，无线程冲突）
                self.update_plot()

                # 等待子线程结束
                gen_thread.join()
                send_thread.join()
                print("所有点位发送完成")

            def __del__(self):
                """析构函数：失能机械臂"""
                if hasattr(self, 'arm'):
                    # self.arm.DisablePiper()  # 补充机械臂失能方法
                    print("机械臂已失能")


        if __name__ == "__main__":
            try:
                motion = ContinuousMotion()
                motion.init_arm()
                motion.start(total_points=200)  # 200个点足够绘制平滑椭圆
            except Exception as e:
                print(f"执行错误：{e}")
