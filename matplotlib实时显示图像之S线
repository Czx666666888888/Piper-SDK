import time
# Import piper_sdk module
from piper_sdk import *

if __name__ == "__main__":
    # Instantiate interface, the default parameters of the parameters are as follows
    #   can_name(str): can port name
    #   judge_flag(bool): Whether to enable the can module when creating this instance.
    #                     If you use an unofficial module, please set it to False
    #   can_auto_init(bool): Whether to automatically initialize to open the can bus when creating this instance.
    #                        If set to False, please set the can_init parameter to True in the ConnectPort parameter
    #   dh_is_offset([0,1] -> default 0x01): Whether the dh parameter used is the new version of dh or the old version of dh.
    #                                       The old version is before S-V1.6-3, and the new version is after S-V1.6-3 firmware
    #           0 -> old
    #           1 -> new
    #   start_sdk_joint_limit(bool -> False): Whether to enable SDK joint angle limit, which will limit both feedback and control messages
    #   start_sdk_gripper_limit(bool -> False): Whether to enable SDK gripper position limit, which will limit both feedback and control messages
    #   logger_level(LogLevel -> default LogLevel.WARNING): Set the log level
    #         The following parameters are optional:
    #               LogLevel.DEBUG
    #               LogLevel.INFO
    #               LogLevel.WARNING
    #               LogLevel.ERROR
    #               LogLevel.CRITICAL
    #               LogLevel.SILENT
    #   log_to_file(bool -> default False): Whether to enable the log writing function, True to enable, default to disable
    #   log_file_path(str -> default False): Set the path to write the log file, the default is the log folder under the sdk path
    piper = C_PiperInterface(can_name="can0",
                                judge_flag=False,
                                can_auto_init=True,
                                dh_is_offset=1,
                                start_sdk_joint_limit=False,
                                start_sdk_gripper_limit=False,
                                logger_level=LogLevel.WARNING,
                                log_to_file=False,
                                log_file_path=None)
    # Enable can send and receive threads
    piper.ConnectPort()
    # Loop and print messages. Note that the first frame of all messages is the default value. For example, the message content of the first frame of the joint angle message defaults to 0
    while True:
        import threading
        import queue
        import numpy as np
        import matplotlib.pyplot as plt



        # 假设piper已正确初始化（根据实际情况补充）
        # piper = ...  # 机械臂对象初始化代码

        class ContinuousMotion:
            def __init__(self):
                self.arm = piper  # 机械臂对象
                self.running = False  # 运动标志位
                self.lock = threading.Lock()  # 仅保护机械臂发送操作
                self.point_buffer = []  # 保留缓冲区但控制长度，避免堆积

                # 关键1：队列设为容量1，强制“生成一个、发送一个”，无缓冲堆积
                self.plot_queue = queue.Queue(maxsize=1)

                # 绘图初始化（关键优化：启用Blitting加速，预设坐标轴范围）
                self.x_history = []
                self.y_history = []
                plt.ion()
                self.fig, self.ax = plt.subplots(figsize=(8, 6), dpi=80)  # 降低dpi减少绘图负载
                self.line, = self.ax.plot([], [], 'b-', linewidth=2, animated=True)  # 开启动画模式（Blitting必需）
                self.ax.set_xlabel('X坐标 (mm)')
                self.ax.set_ylabel('Y坐标 (mm)')
                self.ax.set_title('机械臂实时轨迹（生成→发送→绘图同步）')
                self.ax.grid(True, linestyle='--', alpha=0.5)  # 简化网格，降低绘制耗时

                # 关键2：预设置坐标轴范围（替代自动缩放，节省大量时间）
                # 按你的点位生成逻辑计算：X从-53.044到-53.044-99*1 = -152.044mm；Y±30mm，范围258.102-328.102mm
                self.ax.set_xlim(-160, -50)
                self.ax.set_ylim(250, 340)

                # Blitting初始化：只重绘变化的线条，绘图耗时压缩到1-2ms
                self.fig.canvas.draw()
                self.background = self.fig.canvas.copy_from_bbox(self.ax.bbox)
                self.fig.canvas.blit(self.ax.bbox)

            def init_arm(self):
                """初始化机械臂（保持原有逻辑）"""
                if not self.arm.EnablePiper():
                    raise RuntimeError("机械臂使能失败")
                self.arm.ModeCtrl(ctrl_mode=0x01, move_mode=0x01, move_spd_rate_ctrl=20)
                time.sleep(2)
                self.arm.JointCtrl(0, 0, 0, 0, 0, 0)
                time.sleep(3)
                self.arm.ModeCtrl(ctrl_mode=0x01, move_mode=0x00, move_spd_rate_ctrl=20)
                time.sleep(2)
                self.arm.EndPoseCtrl(-53044, 298102, 31758, 176745, -915, -86313)
                time.sleep(3)
                self.arm.ModeCtrl(ctrl_mode=0x01, move_mode=0x02, move_spd_rate_ctrl=15)
                time.sleep(2)
                print("机械臂初始化完成，进入连续运动模式")

            def generate_continuous_points(self, total_points=300):
                """关键3：调整生成节奏，与发送/绘图对齐，无批量堆积"""
                start_x, start_y, start_z, rx, ry, rz = (-53044, 298102, 31758, 176745, -915, -86313)
                for i in range(total_points):
                    x = start_x - i * 1000  # X每步-1mm
                    y = start_y + int(30000 * np.sin(i * 0.1))  # Y波动±30mm
                    z = start_z

                    # 控制缓冲区长度≤1，避免生成过快导致堆积
                    with self.lock:
                        if len(self.point_buffer) < 1:
                            self.point_buffer.append((x, y, z, rx, ry, rz))

                    # 关键4：生成延迟与发送延迟一致（0.02s），节奏对齐
                    time.sleep(0.02)

            def send_continuous_points(self):
                """子线程：发送点位并即时入队，无额外延迟"""
                print("开始连续发送点位...")
                while self.running or len(self.point_buffer) > 0:
                    with self.lock:
                        if self.point_buffer:
                            current_pose = self.point_buffer.pop(0)
                            self.arm.EndPoseCtrl(*current_pose)
                            x_mm = current_pose[0] / 1000
                            y_mm = current_pose[1] / 1000
                            print(f"发送点位：X={x_mm:.2f}mm, Y={y_mm:.2f}mm")

                            # 关键5：队列满时阻塞，确保“发送一个才入队下一个”
                            self.plot_queue.put((x_mm, y_mm), block=True)

                    # 发送延迟保持0.02s，与生成/绘图节奏匹配
                    time.sleep(0.02)

                # 发送结束标志
                self.plot_queue.put(None)

            def update_plot(self):
                """关键6：Blitting极速绘图，消除延迟"""
                while True:
                    item = self.plot_queue.get(timeout=1)
                    if item is None:
                        break
                    x, y = item
                    self.x_history.append(x)
                    self.y_history.append(y)

                    # 更新轨迹数据
                    self.line.set_xdata(self.x_history)
                    self.line.set_ydata(self.y_history)

                    # Blitting快速重绘（仅更新线条，不重绘整个画布）
                    self.fig.canvas.restore_region(self.background)  # 恢复背景
                    self.ax.draw_artist(self.line)  # 只绘制变化的线条
                    self.fig.canvas.blit(self.ax.bbox)  # 刷新变化区域
                    self.fig.canvas.flush_events()  # 处理事件，避免卡顿

                # 所有点处理完成后保持图像
                plt.ioff()
                plt.show()

            def start(self, total_points=100):
                """启动流程（保持原有线程结构，优化节奏对齐）"""
                self.running = True

                # 启动点位生成线程
                gen_thread = threading.Thread(target=self.generate_continuous_points, args=(total_points,))
                gen_thread.start()

                # 启动点位发送线程
                send_thread = threading.Thread(target=self.send_continuous_points)
                send_thread.start()

                # 主线程负责绘图（确保绘图在主线程，无线程冲突）
                self.update_plot()

                # 等待子线程结束
                gen_thread.join()
                send_thread.join()
                print("所有点位发送完成")

            def __del__(self):
                """析构函数：失能机械臂"""
                if hasattr(self, 'arm'):
                    # self.arm.DisablePiper()  # 补充机械臂失能方法
                    print("机械臂已失能")


        if __name__ == "__main__":
            try:
                motion = ContinuousMotion()
                motion.init_arm()
                motion.start(total_points=100)  # 启动连续运动
            except Exception as e:
                print(f"执行错误：{e}")
